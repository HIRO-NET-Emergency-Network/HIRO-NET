function [FT_BASE,FT_POI,longestPath,G,GLP] = computeOptimalSearchFlightPlan(x_BASES,y_BASES,x_fordrone,y_fordrone,speed,N_poi,MAX_FLIGHT_TIME,REWARDS,index_base)
%COMPUTEOPTIMALSEARCHFLIGHTPLAN This function computes the optimal flight plan for a given drone.
%   This function computes the optimal flight plan that maximizes the
%   reward achieved by visiting PoIs while satisfying the maximum flight time constraint.

% Compute the flight time to reach each PoI and to go back to the base.
[FT_BASE, FT_POI] = gererateFlightTimes(x_BASES(index_base),y_BASES(index_base),x_fordrone,y_fordrone,speed,N_poi);

% Generate a fully connected undirected graph and its corresponging
% adjacency matrix.
[~,matrix_adj]= generateAdjMatrix(N_poi); 

% Run a brute-force algorithm to find the optimal path. The problem can equivalently stated as a Longest Path Problem with budget (e.g., flight time) constraint.
% In a next release, we will also include a near-optimal low-complexity solution and
% let the system decide which one to use according to the number of PoIs to
% be visited. Furthermore, in the next release we will also consider the
% case where a drone is allowed to land and recharge batteries on any available base.
[longestPath,~,~] = runBruteForceLongestPath(N_poi,MAX_FLIGHT_TIME,FT_BASE,FT_POI,REWARDS); 

% To reduce the computational complexity, in runBruteForceLongestPath() we
% do not add the base station in the graph. Thus, we have to add the base
% here as the start and end point. 
xxx = zeros(N_poi+1,N_poi+1);
xxx(1,longestPath(1)+1) = 1;
if length(longestPath) == 1
    xxx(longestPath(1)+1,1) = 1;
else
    for i = 1 : (length(longestPath)-1)
        xxx(longestPath(i)+1,longestPath(i+1)+1) = 1;
    end
    xxx(longestPath(i+1)+1,1) = 1;
end

% This is the original fully connected undirected graph
G = digraph(matrix_adj);

% This is the directed graph generated by the optimization algorithm
GLP = digraph(xxx);

end